package lume

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
	modellume "github.com/mcdev12/lumo/go/internal/models/lume"
	"github.com/mcdev12/lumo/go/internal/repository/db/sqlc"
	"github.com/sqlc-dev/pqtype"
)

// CreateLumeRequest represents the data needed to create a new Lume
type CreateLumeRequest struct {
	LumeID      uuid.UUID // Now provided by app layer!
	LumoID      uuid.UUID
	Label       string
	Type        modellume.LumeType
	Description *string
	Metadata    map[string]interface{}
}

// UpdateLumeRequest represents the data needed to update an existing Lume
type UpdateLumeRequest struct {
	Label       string
	Type        modellume.LumeType
	Description *string
	Metadata    map[string]interface{}
}

// Repository is the concrete implementation
type Repository struct {
	queries *sqlc.Queries
}

// NewRepository creates a new Repository instance
func NewRepository(db sqlc.DBTX) *Repository {
	return &Repository{
		queries: sqlc.New(db),
	}
}

// CreateLume creates a new Lume record
func (r *Repository) CreateLume(ctx context.Context, req CreateLumeRequest) (*modellume.Lume, error) {
	now := time.Now()

	params := sqlc.CreateLumeParams{
		LumeID:    req.LumeID,
		LumoID:    req.LumoID,
		Label:     req.Label,
		Type:      string(req.Type),
		CreatedAt: now,
		UpdatedAt: now,
	}

	if req.Description != nil {
		params.Description = sql.NullString{String: *req.Description, Valid: true}
	}

	if req.Metadata != nil {
		metadataBytes, err := json.Marshal(req.Metadata)
		if err != nil {
			return nil, err
		}
		params.Metadata = pqtype.NullRawMessage{RawMessage: metadataBytes, Valid: true}
	}

	result, err := r.queries.CreateLume(ctx, params)
	if err != nil {
		return nil, err
	}

	// FIXED: Correct UUID mapping
	return r.sqlcRowToDomainModel(
		result.ID,     // Internal ID
		result.LumeID, // Lume UUID (generated by SQL)
		result.LumoID, // Lumo UUID (provided by us)
		result.Label,
		result.Type,
		result.Description,
		result.Metadata,
		result.CreatedAt,
		result.UpdatedAt,
	), nil
}

// GetLumeByID retrieves a Lume by its internal ID
func (r *Repository) GetLumeByID(ctx context.Context, id int64) (*modellume.Lume, error) {
	result, err := r.queries.GetLumeByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return r.sqlcRowToDomainModel(
		result.ID,
		result.LumeID,
		result.LumoID, // FIXED: Correct field mapping
		result.Label,
		result.Type,
		result.Description,
		result.Metadata,
		result.CreatedAt,
		result.UpdatedAt,
	), nil
}

// GetLumeByLumeID retrieves a Lume by its UUID
func (r *Repository) GetLumeByLumeID(ctx context.Context, lumeID uuid.UUID) (*modellume.Lume, error) {
	result, err := r.queries.GetLumeByLumeID(ctx, lumeID)
	if err != nil {
		return nil, err
	}

	return r.sqlcRowToDomainModel(
		result.ID,
		result.LumeID,
		result.LumoID, // FIXED: Correct field mapping
		result.Label,
		result.Type,
		result.Description,
		result.Metadata,
		result.CreatedAt,
		result.UpdatedAt,
	), nil
}

// ListLumesByLumoID retrieves all Lumes associated with a given Lumo ID
func (r *Repository) ListLumesByLumoID(ctx context.Context, lumoID uuid.UUID, limit, offset int32) ([]*modellume.Lume, error) {
	params := sqlc.ListLumesByLumoIDParams{
		LumoID: lumoID,
		Limit:  limit,
		Offset: offset,
	}

	results, err := r.queries.ListLumesByLumoID(ctx, params)
	if err != nil {
		return nil, err
	}

	lumes := make([]*modellume.Lume, len(results))
	for i, result := range results {
		lumes[i] = r.sqlcRowToDomainModel(
			result.ID,
			result.LumeID,
			result.LumoID, // FIXED: Correct field mapping
			result.Label,
			result.Type,
			result.Description,
			result.Metadata,
			result.CreatedAt,
			result.UpdatedAt,
		)
	}

	return lumes, nil
}

// UpdateLume updates an existing Lume record
func (r *Repository) UpdateLume(ctx context.Context, id int64, req UpdateLumeRequest) (*modellume.Lume, error) {
	params := sqlc.UpdateLumeParams{
		ID:        id,
		Label:     req.Label,
		Type:      string(req.Type),
		UpdatedAt: time.Now(),
	}

	if req.Description != nil {
		params.Description = sql.NullString{String: *req.Description, Valid: true}
	}

	if req.Metadata != nil {
		metadataBytes, err := json.Marshal(req.Metadata)
		if err != nil {
			return nil, err
		}
		params.Metadata = pqtype.NullRawMessage{RawMessage: metadataBytes, Valid: true}
	}

	result, err := r.queries.UpdateLume(ctx, params)
	if err != nil {
		return nil, err
	}

	return r.sqlcRowToDomainModel(
		result.ID,
		result.LumeID,
		result.LumoID, // FIXED: Correct field mapping
		result.Label,
		result.Type,
		result.Description,
		result.Metadata,
		result.CreatedAt,
		result.UpdatedAt,
	), nil
}

// DeleteLume deletes a Lume by its ID
func (r *Repository) DeleteLume(ctx context.Context, id int64) error {
	return r.queries.DeleteLume(ctx, id)
}

// Helper method to convert SQLC results to domain model
func (r *Repository) sqlcRowToDomainModel(
	id int64, // Internal database ID
	lumeID uuid.UUID, // UUID for this Lume (generated by DB)
	lumoID uuid.UUID, // UUID for parent Lumo (provided by user)
	label string,
	lumeType string,
	description sql.NullString,
	metadata pqtype.NullRawMessage,
	createdAt time.Time,
	updatedAt time.Time,
) *modellume.Lume {
	lume := &modellume.Lume{
		Id:        id,              // Internal ID (int64)
		LumeId:    lumeID.String(), // Lume UUID (string) - generated by DB
		LumoID:    lumoID.String(), // Lumo UUID (string) - provided by user
		Label:     label,
		Type:      modellume.LumeType(lumeType),
		CreatedAt: createdAt,
		UpdatedAt: updatedAt,
	}

	if description.Valid {
		lume.Description = description.String
	}

	if metadata.Valid {
		var metadataMap map[string]interface{}
		if err := json.Unmarshal(metadata.RawMessage, &metadataMap); err == nil {
			lume.Metadata = metadataMap
		}
	}

	return lume
}
